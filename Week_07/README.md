# Week7学习笔记

​		本周学习内容为字典树和并查集、高级搜索、红黑树和AVL树。

## 字典树

### 字典树(Trie树)

​		又称单词查找树或键树，是一种树形结构（区别于二叉树）。

​		典型应用是：统计和排序大量的字符串（不仅限于字符串）。所以经常被搜索引擎系统用于文本词频统计。

​		优点：最大限度地减少无谓的字符串比较，查询效率比哈希表高。

​		基本性质：

​				1. 节点本身不存完整单词

​				2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串

​				3. 每个节点的所有子节点路径代表的字符都不相同

#### 作业题

​		LeetCode 212题，单词搜索II，分析时间复杂度。

​		解题思路：将words中的单词放入Trie树，再用回溯算法解决。

​		时间复杂度：需要遍历一遍board，故肯定有m*n次循环；回溯算法过程中，假设单词最长长度为L，则最坏情况每次遍历L次；对每一个字母，有四个方向，每个方向有三个出路；故时间复杂度为O(m * n * 4 * 3 ^ (L - 1))



## 并查集

​		主要是解决判断有多少个圈子，两个对象是不是一个集合之类的问题。

​		实现一个并查集的基本操作：

​			makeSet(s)：建立一个新的并查集，其中包含s个单元素集合

​			unionSet(x, y)：把元素x和元素y所在的集合合并，要求x和y所在的集合不想交，如果相交则不合并

​			find(x)：找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将各自代表比较一下就可以了

代码模板：

```Java
class UnionFind { 
	private int count = 0; 
	private int[] parent; 
	public UnionFind(int n) { 
		count = n; 
		parent = new int[n]; 
		for (int i = 0; i < n; i++) { 
			parent[i] = i;
		}
	} 
	public int find(int p) { 
		while (p != parent[p]) { 
			parent[p] = parent[parent[p]]; 
			p = parent[p]; 
		}
		return p; 
	}
	public void union(int p, int q) { 
		int rootP = find(p); 
		int rootQ = find(q); 
		if (rootP == rootQ) return; 
		parent[rootP] = rootQ; 
		count--;
	}
}
```



## AVL和红黑树

​		这两部分主要明白抽象原理和特点及应用，不需要阅读源码或练习题，关键记住几个考点。

​		AVL是平衡搜索二叉树，红黑树是近似平衡搜索二叉树，其中平衡指的左右子树的高度尽量保持一致。引入这两种结构，是为了保证二叉树的性能，避免二叉树退化成近似链表的结构，提高增删改查效率。

​		二叉树在查询时的效率与树的深度相关；为了保证树的高度尽量小，需要保证各节点左右子树的高度差尽量小，进而引入平衡因子这个概念；当平衡因子超过限定范围时，就要进行旋转操作保证平衡。

### AVL

​		平衡因子：左子树高度减去右子树高度（或相反）。需要在操作过程中始终保持平衡因子的取值范围为{-1，0，1}

​		通过四种旋转操作进行平衡：左旋，右旋，左右旋，右左旋。需要厘清各种操作的意义，注意旋转过程中，子树的交换。

​		不足点：节点需要存储额外信息（int型，4个字节），且调整次数频繁。

### 红黑树

​		是近似平衡搜索二叉树，确保任何一个节点的左右子树高度差小于两倍。

​		特点：满足这几个特点的就是近似平衡二叉树

​			1. 每个结点要么红色要么黑色

​			2. 根结点是黑色

​			3. 每个叶子结点（NIL、空节点）是黑色

​			4. 不能有相邻两个红色结点

​			5. 从任一结点到其每个叶子结点的所有路径都包含相同数目的黑色节点



### AVL和红黑树对比

1. AVL查询速度比红黑树快，因为AVL更平衡；
2. 红黑树插入删除操作比AVL更快和简单，因为红黑树的结构要求相对宽松
3. AVL的每个结点需要额外存储int大小4个字节，而红黑树只需要1个字节
4. 红黑树多用于插入删除多的场景，如高级语言库里；AVL多用于查询多的场景，如DB；当各种操作都差不多多的时候，用红黑树